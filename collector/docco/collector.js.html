<!DOCTYPE html>

<html>
<head>
  <title>collector.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>collector.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> fnv = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hash.fnv'</span>)
<span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Collector</span> (<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">this</span>._async = <span class="hljs-keyword">async</span>
    <span class="hljs-keyword">this</span>._buffers = []
    <span class="hljs-keyword">this</span>.chunkNumber = <span class="hljs-number">0</span>
    <span class="hljs-keyword">this</span>._previousChecksum = <span class="hljs-number">0xaaaaaaaa</span>
    <span class="hljs-keyword">this</span>._initializations = <span class="hljs-number">0</span>
    <span class="hljs-keyword">this</span>.chunks = []
    <span class="hljs-keyword">this</span>.stderr = []
    <span class="hljs-keyword">this</span>._state = <span class="hljs-string">'seek'</span>
}

</pre></div></div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>TODO We control the asynchronous stream, so we know that the messages on that
stream are for us, but we do not control the synchronous stream, it is going
to be standard error. We do not want to assert that standard error is used
for nothing but Prolific logging. That is going to frustrate our dear user
when our dear user is using a 3rd party library that is beyond our dear
user’s control. Our dear user will be most disappointed in us for this
stricture. Thus, we need to scan past the noise of ordinary standard error.
Our messages will be at the very end, the last messages out as we flush the
logging buffer on exit.</p>
<p>Our header is simple, four integers on a line expressed in UTF-8. It is not
unlikely for us to find four integers on a line in ordinary standard I/O
spew. How do we verify that four integers on a line on standard out
constitute a Prolific logging header and not some arbitrary spew?</p>
<p>We could gather the numbers and then use the sequence. If it is less than the
current sequence, we ignore it. If it is greater, we wait for the sequence to
arrive on the async logging output, then check the checksums before
proceeding. The problem is that the header might be arbitrary spew and the
spewed sequence number might be impossibly high, which means that we’re going
to block standard error for a long, long time.</p>
<p>We could put a distance limit, but that is an arbitrary limit, so we’re
hoping for the best. What if there are logging messages on the async log are
coming slow while spew on standard error is coming fast? This is highly
likely in some degenerate states. We really want to be a deterministic as
possible, which is probalby a misuse of the word deterministic, given how
vital we are to diagnosing unreproducable errors.</p>
<p>We could gather up the buffer, then let the bits flow again. Problem there is
that an arbitrary spew header would have an aribtrary length that might
swallow the actual header, so we’re going to need to back track, and now
we’re consuming memory, not for buffering, but for retention, which we do not
want to do.</p>
<p>What I’ve come up with is this; the stream state is one where it goes from an
aribitrary stream to a Prolific stream. The asynchronous stream begins as a
Prolific stream. While the program is running it is the source of logging
messages, the synchronous is emitting arbitrary blather. When the program
ends the  synchronous stream will switch and when it does it takes over as
the source of logging messages. It could still have abitrary blather in it
that we must skip, but the Prolific messages will come in contiguous headers
and chunks.</p>
<p>To keep from swallowing, the initial message on the synchronous stream is a
zero length message. The previous checksum references the initial checksum.
The current checksum is the , ah! The first message in a stream is a previous
checksum.</p>

            </div>

            <div class="content"><div class='highlight'><pre>Collector.prototype.scan = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">buffer</span>) </span>{
    <span class="hljs-keyword">var</span> scan = { <span class="hljs-attr">buffer</span>: buffer, <span class="hljs-attr">index</span>: <span class="hljs-number">0</span> }, scanned = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">while</span> (scanned) {
        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>._state) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'seek'</span>:
            scanned = <span class="hljs-keyword">this</span>._seek(scan)
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">'header'</span>:
            scanned = <span class="hljs-keyword">this</span>._scanHeader(scan)
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">'chunk'</span>:
            scanned = <span class="hljs-keyword">this</span>._scanChunk(scan)
            <span class="hljs-keyword">break</span>
        }
    }
    <span class="hljs-keyword">if</span> (scan.index &lt; scan.buffer.length) {
        <span class="hljs-keyword">this</span>._buffers.push(<span class="hljs-keyword">new</span> Buffer(buffer.slice(scan.index)))
    }
}

Collector.prototype._scanChunk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scan</span>) </span>{
    <span class="hljs-keyword">var</span> remaining = <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>._chunk.remaining, scan.buffer.length - scan.index)
    <span class="hljs-keyword">this</span>._buffers.push(<span class="hljs-keyword">new</span> Buffer(scan.buffer.slice(scan.index, scan.index + remaining)))
    scan.index += remaining
    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>._chunk.remaining -= remaining) == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> buffer = Buffer.concat(<span class="hljs-keyword">this</span>._buffers)
        <span class="hljs-keyword">this</span>._buffers.length = <span class="hljs-number">0</span>
        <span class="hljs-keyword">var</span> checksum = fnv(<span class="hljs-number">0</span>, buffer, <span class="hljs-number">0</span>, buffer.length)
        assert(checksum == <span class="hljs-keyword">this</span>._chunk.checksum, <span class="hljs-string">'invalid checksum'</span>)
        <span class="hljs-keyword">this</span>.chunks.push({
            <span class="hljs-attr">number</span>: <span class="hljs-keyword">this</span>._chunk.number,
            <span class="hljs-attr">previousChecksum</span>: <span class="hljs-keyword">this</span>._previousChecksum,
            <span class="hljs-attr">checksum</span>: <span class="hljs-keyword">this</span>._chunk.checksum,
            <span class="hljs-attr">length</span>: <span class="hljs-keyword">this</span>._chunk.length,
            <span class="hljs-attr">buffer</span>: buffer
        })
        <span class="hljs-keyword">this</span>._chunk = <span class="hljs-literal">null</span>
        <span class="hljs-keyword">this</span>._state = <span class="hljs-string">'seek'</span>
        <span class="hljs-keyword">this</span>.chunkNumber++
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}

Collector.prototype._push = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scan, i</span>) </span>{
    <span class="hljs-keyword">this</span>._buffers.push(<span class="hljs-keyword">new</span> Buffer(scan.buffer.slice(scan.index, i)))
    scan.index = i
}

Collector.prototype._flush = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> Buffer.concat(<span class="hljs-keyword">this</span>._buffers.splice(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>._buffers.length))
}

Collector.prototype._scanned = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scan, i</span>) </span>{
    <span class="hljs-keyword">this</span>._push(scan, i)
    <span class="hljs-keyword">var</span> scanned = <span class="hljs-keyword">this</span>._flush()
    <span class="hljs-keyword">if</span> (scanned.length != <span class="hljs-number">0</span>) {
        assert(!<span class="hljs-keyword">this</span>._async, <span class="hljs-string">'garbage before header'</span>)
        <span class="hljs-keyword">this</span>.stderr.push(scanned)
    }
}

Collector.prototype._seek = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scan</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> buffer = scan.buffer, i = scan.index, I = buffer.length; i &lt; I; i++) {
        <span class="hljs-keyword">if</span> (buffer[i] == <span class="hljs-number">0x25</span>) {
            <span class="hljs-keyword">this</span>._state = <span class="hljs-string">'header'</span>
            <span class="hljs-keyword">this</span>._scanned(scan, i)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buffer[i] == <span class="hljs-number">0xa</span>) {
            <span class="hljs-keyword">this</span>._scanned(scan, i + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}

</pre></div></div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>TODO How do you really debug a problem with a stream? You need more than a
stack trace, you need a sample of the stream.</p>
<p>TODO Some more theory. The checksums here only exist to detect the switch
between the logging stream and the final message from standard out. The
likelihood of corruption on a unix pipe between parent and child is slim, our
ability to anything reasonable in the face of such corruption is
non-existant.</p>
<p>TODO Here we are revisiting a balance between correctness and complexity,
essentally answering an admonishment, when I believe that the answer I’ve
come to is that adding code doesn’t add stability. Stability comes from
deployment first, and then the passage of time.</p>

            </div>

            <div class="content"><div class='highlight'><pre>Collector.prototype._scanHeader = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scan</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> buffer = scan.buffer, i = scan.index, I = buffer.length; i &lt; I; i++) {
        <span class="hljs-keyword">if</span> (buffer[i] == <span class="hljs-number">0xa</span>) {
            <span class="hljs-keyword">break</span>
        }
    }
    <span class="hljs-keyword">if</span> (i != I) {
        <span class="hljs-keyword">this</span>._push(scan, i + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">var</span> header = <span class="hljs-keyword">this</span>._flush()
        <span class="hljs-keyword">var</span> $ = <span class="hljs-regexp">/^% (\d+) ([0-9a-f]{8}) ([0-9a-f]{8}) (\d+)\n$/i</span>.exec(header.toString())
        <span class="hljs-keyword">if</span> ($) {
            <span class="hljs-keyword">var</span> chunk = {
                <span class="hljs-attr">number</span>: +$[<span class="hljs-number">1</span>],
                <span class="hljs-attr">checksum</span>: <span class="hljs-built_in">parseInt</span>($[<span class="hljs-number">3</span>], <span class="hljs-number">16</span>),
                <span class="hljs-attr">length</span>: +$[<span class="hljs-number">4</span>],
                <span class="hljs-attr">remaining</span>: +$[<span class="hljs-number">4</span>]
            }
            <span class="hljs-keyword">var</span> previousChecksum = <span class="hljs-built_in">parseInt</span>($[<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)
            <span class="hljs-keyword">if</span> (previousChecksum == <span class="hljs-keyword">this</span>._previousChecksum) {
                <span class="hljs-keyword">if</span> (chunk.number == <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._initializations == <span class="hljs-number">0</span> || (<span class="hljs-keyword">this</span>._initializations == <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-keyword">this</span>._async)) {
                        <span class="hljs-keyword">this</span>.chunkNumber = chunk.remaining
                        <span class="hljs-keyword">this</span>._previousChecksum = chunk.checksum
                        <span class="hljs-keyword">this</span>._initializations++
                    } <span class="hljs-keyword">else</span> {
                        assert(!<span class="hljs-keyword">this</span>._async, <span class="hljs-string">'already initialized'</span>)
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chunk.number == <span class="hljs-keyword">this</span>.chunkNumber) {
                    <span class="hljs-keyword">this</span>._state = <span class="hljs-string">'chunk'</span>
                    <span class="hljs-keyword">this</span>._chunk = chunk
                    <span class="hljs-keyword">this</span>._previousChecksum = chunk.checksum
                } <span class="hljs-keyword">else</span> {
                    assert(!<span class="hljs-keyword">this</span>._async, <span class="hljs-string">'chunk numbers incorrect'</span>)
                }
            } <span class="hljs-keyword">else</span> {
                assert(!<span class="hljs-keyword">this</span>._async, <span class="hljs-string">'async stream sequence break'</span>)
                <span class="hljs-keyword">this</span>.stderr.push(header)
            }
        } <span class="hljs-keyword">else</span> {
            assert(!<span class="hljs-keyword">this</span>._async, <span class="hljs-string">'async stream garbled header'</span>)
            <span class="hljs-keyword">this</span>.stderr.push(header)
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}

<span class="hljs-built_in">module</span>.exports = Collector

</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
